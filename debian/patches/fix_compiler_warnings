Description: use several compiler warnings
Author: Johann Felix Soden <johfel@gmx.de>

--- a/pdftk/pdftk.cc
+++ b/pdftk/pdftk.cc
@@ -148,7 +148,7 @@
 		fn= buff;
 	}
 
-	if( buff_size== fn.size() ) { // might have been too long for buff
+	if( buff_size== (int) fn.size() ) { // might have been too long for buff
 		cout << "The name you entered might have exceeded our internal buffer." << endl;
 		cout << "   Please review it and make sure it wasn't truncated:" << endl;
 		cout << fn << endl;
@@ -851,7 +851,22 @@
 	m_valid_b( false ),
 	m_authorized_b( true ),
 	m_input_pdf_readers_opened_b( false ),
-  m_operation( none_k ),
+	m_verbose_reporting_b( false ),
+	m_ask_about_warnings_b( ASK_ABOUT_WARNINGS ), // set default at compile-time
+	m_input_pdf(),
+	m_input_pdf_index(),
+	m_input_attach_file_filename(),
+	m_input_attach_file_pagenum( 0 ),
+	m_update_info_filename(),
+	m_update_xmp_filename(),
+	m_operation( none_k ),
+	m_page_seq(),
+	m_form_data_filename(),
+	m_background_filename(),
+	m_stamp_filename(),
+	m_output_filename(),
+	m_output_owner_pw(),
+	m_output_user_pw(),
 	m_output_user_perms( 0 ),
 	m_output_uncompress_b( false ),
 	m_output_compress_b( false ),
@@ -859,10 +874,8 @@
 	m_output_drop_xfa_b( false ),
 	m_output_keep_first_id_b( false ),
 	m_output_keep_final_id_b( false ),
-	m_output_encryption_strength( none_enc ),
-	m_verbose_reporting_b( false ),
-	m_ask_about_warnings_b( ASK_ABOUT_WARNINGS ), // set default at compile-time
-	m_input_attach_file_pagenum( 0 )
+	m_output_encryption_strength( none_enc )
+
 {
 	TK_Session::ArgState arg_state = input_files_e;
 
@@ -1351,7 +1364,7 @@
 						if( (!even_pages_b || !(kk % 2)) &&
 								(!odd_pages_b || (kk % 2)) )
 							{
-								if( 0<= kk && kk<= m_input_pdf[range_pdf_index].m_num_pages ) {
+								if( (int) kk<= m_input_pdf[range_pdf_index].m_num_pages ) {
 
 									// look to see if this page of this document
 									// has already been referenced; if it has,
@@ -1591,7 +1604,7 @@
 					for( InputPdfIndex ii= 0; ii< m_input_pdf.size(); ++ii ) {
 						InputPdf& input_pdf= m_input_pdf[ii];
 
-						for( PageNumber jj= 1; jj<= input_pdf.m_num_pages; ++jj ) {
+						for( PageNumber jj= 1; (int) jj<= input_pdf.m_num_pages; ++jj ) {
 							m_page_seq.push_back( PageRef( ii, jj ) ); // DF rotate
 							m_input_pdf[ii].m_readers.back().first.insert( jj ); // mark our claim
 						}
@@ -2300,7 +2313,7 @@
 				// try opening the PDF background or stamp before we get too involved
 				itext::PdfReader* mark_p= 0;
 				bool background_b= true; // set false for stamp
-				com::lowagie::text::pdf::PdfImportedPage* mark_page_p= 0;
+				//com::lowagie::text::pdf::PdfImportedPage* mark_page_p= 0;
 				//
 				if( !m_background_filename.empty() ) {
 					if( m_background_filename== "PROMPT" ) {
@@ -2642,6 +2655,9 @@
 				this->unpack_files( input_reader_p );
 			}
 			break;
+			default:
+			 // nothing to do
+			break;
 			}
 		}
 		catch( java::lang::Throwable* t_p )
--- a/pdftk/attachments.cc
+++ b/pdftk/attachments.cc
@@ -243,7 +243,7 @@
 			if( catalog_p && catalog_p->isDictionary() ) {
 
 				// the Names dict
-				itext::PdfIndirectReference* names_ref_p= 0;
+				//itext::PdfIndirectReference* names_ref_p= 0;
 				itext::PdfDictionary* names_p= (itext::PdfDictionary*)
 					input_reader_p->getPdfObject( catalog_p->get( itext::PdfName::NAMES ) );
 				bool names_new_b= false;
@@ -455,7 +455,7 @@
 		if( catalog_p && catalog_p->isDictionary() ) {
 
 			// the Names dict
-			itext::PdfIndirectReference* names_ref_p= 0;
+			//itext::PdfIndirectReference* names_ref_p= 0;
 			itext::PdfDictionary* names_p= (itext::PdfDictionary*)
 				input_reader_p->getPdfObject( catalog_p->get( itext::PdfName::NAMES ) );
 			if( names_p && names_p->isDictionary() ) {
--- a/pdftk/report.cc
+++ b/pdftk/report.cc
@@ -385,8 +385,8 @@
 
 static void
 ReportInfo( ostream& ofs,
-						itext::PdfDictionary* info_p,
-						itext::PdfReader* reader_p )
+						itext::PdfDictionary* info_p
+						)
 {
 	if( info_p && info_p->isDictionary() ) {
 		java::Set* keys_p= info_p->getKeys();
@@ -576,7 +576,8 @@
 	set< string > m_states; // possible states
 	string m_state;
 
-	FormField() : m_ff(0), m_qq(0), m_maxlen(0) {}
+	FormField() : m_ft(), m_tt(), m_tu(), m_ff(0), m_vv(), m_dv(), m_qq(0), m_ds(), m_rv(), m_maxlen(0),
+		      m_states(),m_state() {}
 };
 
 static void
@@ -956,7 +957,7 @@
 					reader_p->getPdfObject( trailer_p->get( itext::PdfName::INFO ) );
 				if( info_p && info_p->isDictionary() ) {
 						
-					ReportInfo( ofs, info_p, reader_p );
+					ReportInfo( ofs, info_p);
 				}
 				else { // warning
 					cerr << "Warning: no info dictionary found" << endl;
--- a/pdftk/pdftk.h
+++ b/pdftk/pdftk.h
@@ -43,7 +43,7 @@
 
 		jint m_num_pages;
 
-		InputPdf() : m_authorized_b(true), m_num_pages(0) {}
+		InputPdf() : m_filename(), m_password(), m_authorized_b(true), m_readers(), m_num_pages(0)  {}
 	};
 	// pack input PDF in the order they're given on the command line
 	vector< InputPdf > m_input_pdf;

Description: Add support for compression for itext >= 2.1.5
 Some code was inspired by the getStreamBytes-implementation of libitext 2.1.7
Author: Johann Felix Soden <johfel@gmx.de>
Bug-Debian: http://bugs.debian.org/547910

--- a/pdftk/pdftk.cc
+++ b/pdftk/pdftk.cc
@@ -42,11 +42,13 @@
 #include <java/lang/String.h>
 #include <java/io/IOException.h>
 #include <java/io/PrintStream.h>
+#include <java/io/ByteArrayOutputStream.h>
 #include <java/io/FileOutputStream.h>
 #include <java/util/Vector.h>
 #include <java/util/ArrayList.h>
 #include <java/util/Iterator.h>
 #include <java/util/HashMap.h>
+#include <java/util/Set.h>
 
 #include "com/lowagie/text/Document.h"
 #include "com/lowagie/text/Rectangle.h"
@@ -76,8 +78,10 @@
 #include "com/lowagie/text/pdf/PdfIndirectObject.h"
 #include "com/lowagie/text/pdf/PdfFileSpecification.h"
 #include "com/lowagie/text/pdf/PdfBoolean.h"
+#include "com/lowagie/text/pdf/PRStream.h"
 
 #include "com/lowagie/text/pdf/RandomAccessFileOrArray.h" // for InputStreamToArray()
+#include "com/lowagie/text/exceptions/UnsupportedPdfException.h"
 
 using namespace std;
 
@@ -155,6 +159,144 @@
 	}
 }
 
+void uncompress_stream(itext::PRStream* stream)
+{
+	try { // try first itext own way
+		stream->setData( itext::PdfReader::getStreamBytes( stream ) );
+		stream->remove( itext::PdfName::FILTER );
+		stream->remove( itext::PdfName::DECODEPARMS );
+	}
+	catch (itext::exceptions::UnsupportedPdfException * err ) { // unknow filter detected
+		itext::RandomAccessFileOrArray *rf = stream->getReader()->getSafeFile();
+		rf->reOpen();
+		itext::PdfObject *filter =
+			itext::PdfReader::getPdfObjectRelease( stream->get( itext::PdfName::FILTER ) );
+		JArray<jbyte>* b = itext::PdfReader::getStreamBytesRaw( stream, rf );
+		java::ArrayList *filters = new java::ArrayList();
+		if( filter ) {
+			if( filter->isName() )
+				filters->add( filter );
+			else if( filter->isArray() )
+				filters = ( (itext::PdfArray*) filter )->getArrayList();
+		}
+		java::ArrayList *dp = new java::ArrayList( ( jint ) 1 );
+		itext::PdfObject *dpo = itext::PdfReader::getPdfObjectRelease(
+				stream->get( itext::PdfName::DECODEPARMS ) );
+		if( !dpo || ( !dpo->isDictionary() && !dpo->isArray() ) )
+			dpo = itext::PdfReader::getPdfObjectRelease( stream->get( itext::PdfName::DP ) );
+		if( dpo ) {
+			if( dpo->isDictionary() )
+				dp->add( dpo );
+			else if( dpo->isArray() )
+				dp = ( (itext::PdfArray*)dpo )->getArrayList();
+		}
+		jstring name;
+		int j;
+		for (j = 0; j < filters->size(); ++j ) {
+			name = ( (itext::PdfName*)itext::PdfReader::getPdfObjectRelease(
+						(itext::PdfObject*)filters->get( j ) ) )->toString();
+			if( name->equals( JvNewStringUTF( "/FlateDecode" ) )
+					|| name->equals( JvNewStringUTF( "/Fl" ) ) ) {
+				b = itext::PdfReader::FlateDecode( b );
+				itext::PdfObject *dicParam = NULL;
+				if( j < dp->size() ) {
+					dicParam = (itext::PdfObject*)dp->get( j );
+					b = itext::PdfReader::decodePredictor( b, dicParam );
+				}
+			}
+			else if( name->equals( JvNewStringUTF( "/ASCII85Decode" ) )
+					|| name->equals( JvNewStringUTF( "/A85" ) ) )
+				b = itext::PdfReader::ASCII85Decode( b );
+			else if( name->equals( JvNewStringUTF( "/ASCIIHexDecode" ) )
+					|| name->equals( JvNewStringUTF( "/AHx" ) ) )
+				b = itext::PdfReader::ASCIIHexDecode( b );
+			else if( name->equals( JvNewStringUTF( "/LZWDecode" ) ) ) {
+				b = itext::PdfReader::LZWDecode( b );
+				itext::PdfObject *dicParam = NULL;
+				if( j < dp->size() ) {
+					dicParam = (itext::PdfObject*)dp->get( j );
+					b = itext::PdfReader::decodePredictor( b, dicParam );
+				}
+			}
+			else if( !name->equals( JvNewStringUTF( "/Crypt" ) ) ){
+				break;
+			}
+		}
+		// remove handled filters
+		for(int k=0; k< j;k++ )
+		{
+			filters->remove( k );
+			if( k < dp->size() )
+				dp->remove( k );
+		}
+		rf->close();
+		stream->setData( b );
+		stream->remove( itext::PdfName::FILTER );
+		stream->remove( itext::PdfName::DECODEPARMS );
+		// write not handled filters back
+		if( filters->size() )
+			stream->put( itext::PdfName::FILTER, new itext::PdfArray( filters ) );
+		if( dp->size() )
+			stream->put( itext::PdfName::DECODEPARMS, new itext::PdfArray( dp ) );
+	}
+}
+
+
+void uncompress_dictionary( itext::PdfDictionary *dict, itext::PdfReader *reader )
+{
+	if( !dict )
+		return;
+
+	// prevent circuit references
+	static set<void*> already_uncompressed;
+	if( already_uncompressed.find(dict) != already_uncompressed.end() )
+		return;
+	already_uncompressed.insert(dict);
+
+	java::util::Iterator * keys=dict->getKeys()->iterator();
+	while( keys->hasNext() ) {
+		itext::PdfName *n = (itext::PdfName*)keys->next();
+		if( !n )
+			continue;
+		itext::PdfObject *obj = dict->get( n );
+		if( !obj || obj == dict )
+			continue;
+		obj = reader->getPdfObject( obj );
+		if( !obj || obj == dict )
+			continue;
+		if( obj->isDictionary() )
+			uncompress_dictionary( (itext::PdfDictionary*)obj,reader );
+		if( obj->isStream() )
+			uncompress_stream( (itext::PRStream*) obj );
+	}
+}
+
+void uncompress( itext::PdfReader * reader )
+{
+	int pages = reader->getNumberOfPages();
+
+	itext::PdfDictionary *catalog = reader->getCatalog();
+	uncompress_dictionary( catalog, reader );
+
+	for( int i=1; i<reader->getXrefSize(); i++ )
+	{
+		itext::PdfObject *obj = reader->getPdfObjectRelease( i );
+		if(!obj)
+			continue;
+		if( obj->isDictionary() )
+			uncompress_dictionary( (itext::PdfDictionary*)obj, reader );
+		if( obj->isStream() )
+			uncompress_stream( (itext::PRStream*)obj );
+	}
+
+	for( int i = 1; i <= pages; i++ )
+	{
+		reader->setPageContent( i, reader->getPageContent( i ), 0 );
+	}
+}
+
+
+
 bool
 TK_Session::add_reader( InputPdf* input_pdf_p )
 {
@@ -505,6 +647,7 @@
 		return perm_all_k;
 	}
 	else if( strcmp( ss_copy, "uncompress" )== 0 ) {
+		itext::Document::Document::compress=false;
 		return filt_uncompress_k;
 	}
 	else if( strcmp( ss_copy, "compress" )== 0 ) {
@@ -2059,14 +2202,15 @@
 				output_doc_p->addCreator( jv_creator_p );
 
 				// un/compress output streams?
-// 				if( m_output_uncompress_b ) {
+ 				if( m_output_uncompress_b ) {
 // 					writer_p->filterStreams= true;
 // 					writer_p->compressStreams= false;
-// 				}
-// 				else if( m_output_compress_b ) {
+ 				}
+ 				else if( m_output_compress_b ) {
 // 					writer_p->filterStreams= false;
 // 					writer_p->compressStreams= true;
-// 				}
+ 					writer_p->setCompressionLevel(9);
+ 				}
 
 				// encrypt output?
 				if( m_output_encryption_strength!= none_enc ||
@@ -2136,10 +2280,13 @@
 
 								//
 								if( m_output_uncompress_b ) {
+									uncompress(input_reader_p);
 									add_mark_to_page( input_reader_p, it->m_page_num, output_page_count+ 1 );
+									writer_p->setCompressionLevel(0);
 								}
 								else if( m_output_compress_b ) {
 									remove_mark_from_page( input_reader_p, it->m_page_num );
+									writer_p->setCompressionLevel(9);
 								}
 
 								// DF rotate
@@ -2214,11 +2361,14 @@
 						// Absent from itext-2.1.4
 // 						writer_p->filterStreams= true;
 // 						writer_p->compressStreams= false;
+ 						writer_p->setCompressionLevel(0);
+						uncompress(input_reader_p);
 					}
 					else if( m_output_compress_b ) {
 						// Absent from itext-2.1.4
 // 						writer_p->filterStreams= false;
 // 						writer_p->compressStreams= true;
+						writer_p->setCompressionLevel(9);
 					}
 
 					// encrypt output?
@@ -2450,16 +2600,19 @@
 
 				// un/compress output streams?
 				if( m_output_uncompress_b ) {
+					uncompress(input_reader_p);
 					add_marks_to_pages( input_reader_p );
 					// Absent from itext-2.1.4
 // 					writer_p->filterStreams= true;
 // 					writer_p->compressStreams= false;
+ 					writer_p->setCompressionLevel(0);
 				}
 				else if( m_output_compress_b ) {
 					remove_marks_from_pages( input_reader_p );
 					// Absent from itext-2.1.4
 // 					writer_p->filterStreams= false;
 // 					writer_p->compressStreams= true;
+ 					writer_p->setCompressionLevel(9);
 				}
 
 				// encrypt output?
